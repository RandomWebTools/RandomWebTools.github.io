<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Appearance Roll Generator</title>
	<!-- Sorry for the massive 2700-character line, that's the only way to put a favicon in a single-page app... -->
	<link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 36 36'%3E%3Cpath fill='%23A0041E' d='M4 11v.137c0-.042.011-.084.015-.126L4 11zm13 11.137c-.146-.067-.287-.145-.412-.246L4.565 12.245C4.188 11.94 4 11.539 4 11.137v12.238c0 2.042 1.093 2.484 1.093 2.484l11.574 9.099c.205.161.377.259.528.318-.114-.174-.195-.375-.195-.604V22.137zm-8.773.363c-.994 0-2.033-1.007-2.319-2.25-.287-1.242.287-2.249 1.28-2.249.994 0 2.033 1.007 2.319 2.249.287 1.243-.286 2.25-1.28 2.25zM13.81 30c-.994 0-2.033-1.008-2.319-2.25-.287-1.243.287-2.25 1.281-2.25s2.033 1.007 2.319 2.25c.286 1.242-.287 2.25-1.281 2.25z'/%3E%3Cpath fill='%23DD2E44' d='M31.435 12.161l-12.104 9.73c-.102.083-.214.152-.331.212v12.569c0 .233-.083.437-.2.614.155-.058.335-.16.548-.328 1.821-1.432 11.588-9.099 11.588-9.099S32 25.417 32 23.375V11.053c0 .402-.188.803-.565 1.108zm-7.457 16.731c-.242 1.137-1.119 2.058-1.958 2.058-.838 0-1.322-.921-1.08-2.058.242-1.137 1.118-2.058 1.957-2.058s1.322.921 1.081 2.058zm3.538-5.271c-.254 1.172-1.178 2.121-2.062 2.121-.883 0-1.392-.949-1.138-2.121.255-1.172 1.179-2.121 2.061-2.121.885 0 1.394.949 1.139 2.121zm3.063-5.105c-.251 1.115-1.163 2.017-2.035 2.017-.872 0-1.375-.902-1.123-2.017.251-1.113 1.162-2.016 2.034-2.016.873 0 1.376.903 1.124 2.016zm1.415-7.511c.001.016.006.032.006.048V11l-.006.005z'/%3E%3Cpath fill='%23EA596E' d='M31.435 9.945L19.289.5c-.753-.61-1.988-.61-2.742 0L4.565 10.029c-.338.273-.515.624-.551.983-.003.042-.014.083-.014.125 0 .402.188.803.565 1.108l12.023 9.646c.125.101.265.178.412.246v12.535c0 .229.081.43.194.604.181.28.466.474.806.474.336 0 .619-.19.8-.464.117-.176.2-.38.2-.614V22.103c.117-.06.229-.129.331-.212l12.104-9.73c.377-.305.565-.706.565-1.108 0-.016-.005-.032-.006-.049-.014-.385-.198-.767-.559-1.059zM18.5 8.667c1.61 0 2.916 1.044 2.916 2.333 0 1.289-1.306 2.333-2.916 2.333-1.611 0-2.916-1.044-2.916-2.333 0-1.289 1.305-2.333 2.916-2.333z'/%3E%3Cellipse fill='%23FFF' cx='18.5' cy='11' rx='2.916' ry='2.333'/%3E%3Cpath fill='%23FFF' d='M29.455 16.5c-.872 0-1.783.903-2.034 2.016-.252 1.115.251 2.017 1.123 2.017s1.784-.902 2.035-2.017c.252-1.113-.251-2.016-1.124-2.016zm-3.077 5c-.883 0-1.807.949-2.061 2.121-.254 1.172.255 2.121 1.138 2.121.884 0 1.808-.949 2.062-2.121.254-1.172-.255-2.121-1.139-2.121zm-3.482 5.334c-.839 0-1.715.921-1.957 2.058-.242 1.137.242 2.058 1.08 2.058.839 0 1.716-.921 1.958-2.058.242-1.137-.242-2.058-1.081-2.058z'/%3E%3Cpath fill='%23E1E8ED' d='M7.188 18.001c-.994 0-1.567 1.007-1.28 2.249.287 1.243 1.325 2.25 2.319 2.25s1.567-1.007 1.28-2.25c-.286-1.242-1.325-2.249-2.319-2.249zm5.583 7.499c-.994 0-1.567 1.007-1.281 2.25.287 1.242 1.326 2.25 2.32 2.25.994 0 1.567-1.008 1.281-2.25-.287-1.243-1.326-2.25-2.32-2.25z'/%3E%3C/svg%3E">
	<style type="text/css">
		body {
			--background: #121212;
			--surface: #2e2e2e;
			--field: #303030;
			--on-background: #eeeeee;
			--on-surface: var(--on-background);
			--text-low-emphasis: #505050;
			--link-low-emphasis: #245493;
			--primary: #3272c5;
			--primary-variant: #235391;
			--on-primary: #121212;
			--secondary: #37902a;
			--secondary-variant: #296e1f;
			--on-secondary: var(--background);
			--disabled: #1b1b1b;
			--enabled: #979797;
			--error:  #ff3030;

			color: var(--on-background);
			background-color: var(--background);
			font-family: sans-serif;
			font-size: 16px;
			display: flex;
			flex-direction: column;
			justify-content: space-between;
			min-height: 100vh;
			margin: 0px;
		}
		#traits-container {
			display: flex;
			margin: 8px;
		}
		.trait-card {
			background-color: var(--background);
			border: 1px solid var(--surface);
			border-radius: 8px;
			margin: 8px;
			padding: 1em;
			display: flex;
			flex-direction: column;
			justify-content: space-between;
		}
		h3 {
			margin: 0px 0px 8px;
		}
		.roll-container {
			margin: 0px 0px 8px;
		}
		.roll-output-container {
			display: flex;
			flex-direction: row;
		}
		button {
			padding: 8px;
			border-radius: 4px;
			border: none;
			background-color: var(--primary);
			color: var(--on-primary);
			font-size: inherit;
		}
		button:hover {
			background-color: var(--primary-variant);
			cursor: pointer;
		}
		/*Button press effect*/
		button:active {
			position: relative;
			top: 1px;
		}
		button.copy {
			background-color: var(--secondary);
			color: var(--on-secondary);
			border-radius: 0px 4px 4px 0px;
		}
		button.copy:hover {
			background-color: var(--secondary-variant);
		}
		input {
			background-color: var(--surface) !important;
			color: var(--on-surface) :!important;
		}
		input:disabled {
			background-color: var(--disabled) !important;
			color: var(--enabled) !important
		}
		input[type='text'] {
		}
		input[type='number'] {
			padding: 8px;
			border-radius: 4px;
			border: none;
			font-size: inherit;
			background-color: var(--surface);
			color: var(--on-surface);
		}
		textarea {
			width: 100%;
			padding: 8px;
			border-radius: 4px 0px 0px 4px;
			border: none;
			margin: 0px;
			background-color: var(--field);
			color: var(--on-surface);
			font-family: monospace;
			font-size: inherit;
		}
		.trait-params {
			margin: 0px 0px 8px;
		}
		.radio-group {
			display: flex;
			flex-direction: column;
			margin: 0px 0px 8px;
		}
		.row-range {
			border: none;
			padding: 8px;
			border-radius: 4px;
			background-color: var(--enabled);
		}
		.divider {
			height: 1px;
			background-color: var(--surface);
			margin: 16px 0px;
		}
		input.roll-count {
			width: 3em;
		}
		.error-message {
			font-style: italic;
			color: var(--error);
			margin-top: 4px;
		}
		#global {
			margin: 16px;
		}
		#global .roll-output-container {
			margin: 8px 0px;
			max-width: 30%;
		}
		/* Custom expression help frame */
		details {
			margin: 16px;
		    padding: .5em;
		    font-size: 14px;
		    max-width: 50%;
		}

		summary {
		    font-weight: bold;
		    margin: -.5em -.5em 0;
		    padding: .5em;
		    cursor: pointer;
		}

		details[open] {
		    border: 1px solid #555;
		    border-radius: 4px;
		    padding: .5em;
		}

		details[open] summary {
		    border-bottom: 1px solid #555;
		    margin-bottom: .5em;
		}
		tt {
			background-color: var(--surface);
			border-radius: 4px;
			padding: 3px;
			display: inline-block;
		}
		footer {
			margin: 16px;
			font-size: small;
			color: var(--text-low-emphasis);
		}
		footer a {
			color: var(--link-low-emphasis);
		}

		/* Small devices (landscape phones, 576px and up) */
		@media (max-width: 768px) {
			#traits-container {
				flex-direction: column;
			}
			#global .roll-output-container {
				max-width: 100%;
			}
			details {
				max-width: 100%;
			}
		}
	</style>
	<script type="text/javascript">

		////////////////////////////////////////////////////////////////////////
		// CONSTANTS ///////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////
		const ERROR_MESSAGE_TIMEOUT = 2000; // milliseconds
		// Constants for custom range parsing
		const ALPHABET = ["A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z"];
		const NEGATE_OPERATOR = "/"
		const TOKEN_SEPARATOR = " ";
		const RANGE_SEPARATOR = ":";
		const ENUM_SEPARATOR  = ",";
		const WILDCARD_ALL = "*";

		let traits;

		////////////////////////////////////////////////////////////////////////
		// CLASSES /////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

		class Preset {
			name;
			humanName;
			filter;

			constructor(humanName, filter) {
				if (name === "all" || name === "custom") {
					throw "Cannot create preset: 'all' and 'custom' are forbidden names";
				}
				this.name = normalize(humanName);
				this.humanName = humanName;
				this.filter = filter;
			}
		}

		class Params {
			row_count;
			col_count;
			presets;
			rootNode;
			radioGroup;
			customField;
			traitName;

			constructor(row_count, col_count, presets=[]) {
				this.row_count = row_count;
				this.col_count = col_count;
				this.presets = presets;
			}

			/**
			 * Initializes the DOM part of the Params that couldn't be initialized in the constructor
			 */
			enable(traitName, cardNode) {
				this.traitName = traitName;
				// Keep references to the root node and the parent trait card it belongs to
				this.rootNode = cardNode.getElementsByClassName("trait-params")[0];
				this.radioGroup = this.rootNode.querySelector('div.radio-group');
				this.customField = cardNode.querySelector(".row-range");


				// Set the right name for all radio buttons in the group, and make them visible
				this.radioGroup.querySelectorAll("label").forEach(function(label) {
					let id = label.getAttribute("for").replace("_trait", this.traitName);
					label.setAttribute("for", id);
					label.firstElementChild.setAttribute("id", id);
					label.firstElementChild.setAttribute("name", `radio-${this.traitName}`);
				}, this);

				// Set a listener to enable/disable custom range field depending on whether the "custom" option is selected
				let params = this;
				this.radioGroup.addEventListener("click", function(event) {
					let target = event.target;
					if (target && target.matches("input[type='radio']")) {
	    				if (target.value === "custom") {
	    					params.customField.removeAttribute('disabled');
	    				} else {
	    					params.customField.setAttribute('disabled', true);
	    				}
					}
				});
				
				this.rootNode.removeAttribute("hidden");
				// Generate radios for presets from template
				for (let preset of this.presets) {
					// Clone first preset node (which is a label containing a radio)
					let newPreset = this.radioGroup.firstElementChild.cloneNode(true);
					let radiobtn = newPreset.getElementsByTagName("input")[0];
					let id = `${this.traitName}-preset-${preset.name}`;
					// Initialize dynamic attributes
					newPreset.setAttribute("for", id);
					radiobtn.setAttribute("id", id);
					radiobtn.setAttribute("value", preset.name);
					radiobtn.removeAttribute("checked");
					newPreset.getElementsByTagName("span")[0].innerText = preset.humanName;
					// Insert node just before last place
					this.radioGroup.lastElementChild.insertAdjacentElement("beforebegin", newPreset);
				}
			}

			getSampleSet() {
				let form = this.rootNode.querySelector('form');
				let data = new FormData(form);
				let entry = data.get(`radio-${this.traitName}`);
				console.log(`Selected entry: ${entry}`);
				if (entry === "all") {
					let samples = [];
					for (let r=0; r<this.row_count; r++) {
						for (let c=0; c<this.col_count; c++) {
							samples.push(`${ this.row_count===1 ? "" : num2let(r+1) }${ this.col_count===1 ? "" : c+1 }`);
						}
					}
					return samples;
				} else {
					let filter;
					if (entry === "custom") {
						filter = this.customField.value;
					} else {
						for (let preset of this.presets) {
							if (preset.name === entry) {
								filter = preset.filter;
								break;
							}
						}
					}
					try {
						return getSamplesCustom(filter, this.row_count, this.col_count);	
					} catch (ex) {
						let errormsg = this.rootNode.querySelector(".error-message");
						errormsg.removeAttribute("hidden");
						setTimeout(function() { errormsg.setAttribute("hidden", true); }, ERROR_MESSAGE_TIMEOUT);
						return [""];
					}
				}
			}
		}

		class Trait {
			id; 			// identifier string
			name; 			// for naming DOM elements in the generated card
			humanName; 		// display name
			cardNode; 		// DOM element of the card
			rollCountNode; 	// DOM element of the roll count input
			rollOutputNode; // DOM element of the output textarea
			getSampleSet;	// function to generate the sample set

			constructor(humanName, values) {
				this.humanName = humanName;
				this.name = normalize(humanName);
				this.shortName = initials(humanName);

				// Clone template card
				this.cardNode = document.getElementById("_trait-template").cloneNode(true);
				// Initialize node fields
				this.rollCountNode = this.cardNode.getElementsByClassName("roll-count")[0];
				this.rollOutputNode = this.cardNode.getElementsByClassName("roll-output")[0];

				// "Fill" the template by setting relevant attributes
				this.id = `trait-${name}`;
				this.cardNode.setAttribute("id", this.id);
				this.cardNode.classList.add("trait-card");
				this.cardNode.getElementsByClassName("trait-name")[0].innerText = humanName;
				let trait = this; // trick to have a reference to this in the listener
				this.cardNode.getElementsByClassName("roll-button")[0].addEventListener("click", function(){ trait.roll(trait.getRollCount()); });
				
				// Auto-resize output textarea on content change
				this.rollOutputNode.addEventListener("input", fitToContent);
				// Add copy-to-clipboard button functionality
				this.cardNode.querySelector("button.copy").addEventListener("click", function(event) {
					navigator.clipboard.writeText(trait.rollOutputNode.value);
				});
				// Finally add new trait card
				document.getElementById("traits-container").appendChild(this.cardNode);
				this.cardNode.removeAttribute("hidden");

				if (values instanceof Function) {
					// A function that gives the sample set from which to roll
					this.getSampleSet = values;
				} else if (values instanceof Params) {
					this.params = values;
					this.params.enable(this.name, this.cardNode);
					this.getSampleSet = function() { return this.params.getSampleSet(); };
				} 
			}

			// Called when the "Roll" button is clicked
			roll(count) {
				console.log(`roll: ${this.name} (${this.humanName})`);
				let sampleSet = this.getSampleSet();
				let result = "";
				for (let i = count; i > 0; i--) {
					result += randPick(sampleSet) + "\n";
				}
				this.rollOutputNode.value = result.slice(0,-1);
				fitToContent(this.rollOutputNode);
			}

			getRollCount() {
				return parseInt(this.rollCountNode.value);
			}
		}

		////////////////////////////////////////////////////////////////////////

		/**
		 * Picks a random value from a array of values
		 */
		function randPick(array) {
			if (Array.isArray(array)) {
				let index = Math.floor(Math.random() * array.length);
				return array[index];
			} else {
				return undefined;
			}
		}

		/**
		 * String manipulation utility: returns the initials of a string
		 * (first letters of each word, capitalized)
		 */
		function initials(string) {
			let output = "";
			for (const word of string.split(" ")) {
				output += word[0];
			}
			return output.toUpperCase();
		}

		/** String manipulation utility: normalizes a string
		 * (strips all non-alphanumeric characters and converts to lowercase)
		 */
		function normalize(string) {
			let output = "";
			for (const c of string.toLowerCase()) {
				if (isLetter(c) || c in ['0','1','2','3','4','5','6','7','8','9']) {
					output += c;
				}
			}
			return output;
		}

		/**
		 * Auto-resizes a textarea depending on the height of its content
		 */
		function fitToContent(textarea) {
			textarea.style.height = "auto";
			textarea.style.height = `${textarea.scrollHeight}px`;
		}

		////////////////////////////////////////////////////////////////////////
		// CUSTOM RANGE PARSING ////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

		/**
		 * Converts a letter to a number 
		 */
		function let2num(letter) {
			if (!isLetter(letter)) throw `'${letter}' is not a valid letter`;
			return parseInt(letter, 36) - 9;
		}

		/**
		 * Converts a number to a letter
		 */
		function num2let(number) {
			try {
				return ALPHABET[number-1];
			} catch (ex) {
				console.error(`${number} is not a valid index for a letter`);
				throw ex;
			}
		}

		function isLetter(str) {
  			return str.length === 1 && str.match(/[a-z]/i);
		}

		/**
		 * Like the Python range function, generates a numeric array from @start to @end with optional @increment
		 */
		function range(start, end, increment=1) {
			let array = [];
			for (let i = start; i < end; i += increment) {
				array.push(i);
			}
			return array;
		}

		function parseRows(selector) {
			if (!isLetter(selector[0])) {
				throw `Invalid row selector '${selector}', must be a single value, a range or an enumeration`;
			}
			let bounds = selector.split(RANGE_SEPARATOR);
			if (bounds.length === 2) {
				// Read it as a range
				return range(let2num(bounds[0]), let2num(bounds[1])+1);
			} else {
				let values = selector.split(ENUM_SEPARATOR);
				if (values.length > 1) {
					// Read it as enumeration
					let result = [];
					for (let i = 0; i < values.length; i++) {
						result.push(let2num(values[i]));
					}
					return result;
				} else {
					return [let2num(selector)];
				}
			}
		}

		function parseColumns(selector) {
			let bounds = selector.split(RANGE_SEPARATOR);
			if (bounds.length === 2) {
				// Read it as a range
				return range(parseInt(bounds[0]), parseInt(bounds[1])+1);
			} else {
				let values = selector.split(ENUM_SEPARATOR);
				if (values.length > 1) {
					// Read it as enumeration
					let result = [];
					for (let i = 0; i < values.length; i++) {
						result.push(parseInt(values[i]));
					}
					return result;
				} else {
					return [parseInt(selector)];
				}
			}
		}

		function parseToken(token, max_row, max_col) {
			let rows, columns, cols_selector;
			if (token[0] === WILDCARD_ALL) {
				rows = range(1, max_row+1);
				cols_selector = token.slice(1);
			} else {
				let rowSelector = "";
				let i = 0;
				const regex = new RegExp(`[a-z${RANGE_SEPARATOR}${ENUM_SEPARATOR}]`, 'i');
				for (i=0; token[i].match(regex); i++) {}
				rows = parseRows(token.slice(0,i));
				cols_selector = token.slice(i);
			}
			// Rows have been parsed, do columns next
			if (cols_selector === WILDCARD_ALL) {
				columns = range(1, max_col+1);
			} else {
				columns = parseColumns(cols_selector);
			}
			// Bounds check
			for (let i = rows.length - 1; i >= 0; i--) {
				if (rows[i] < 0 || rows[i] > max_row) {
					throw `Row values cannot exceed ${num2let(max_row)}`
				}
			}
			for (let i = columns.length - 1; i >= 0; i--) {
				if (columns[i] < 0 || columns[i] > max_col) {
					throw `Column values cannot exceed ${max_col}`
				}
			}

			return {rows, columns};
		}

		/**
		 * Prints the boolean grid representing the samples used for the roll
		 */
		function _printSamplesTable(table) {
			let out = "";
			for (row of table) {
				for (cell of row) {
					out += (cell ? "X" : "O");
				}
				out += "\n";
			}
			console.log(out);
		}

		/**
		 * Parses an expression representing the values included in/excluded from the roll,
		 * and returns the array of effective values to use.
		 */
		function getSamplesCustom(expr, max_row, max_col) {
			let negate = false;
			let table = [];
			// Default to all if expression is empty
			if (expr === "") expr = "**"; 
			try {
				// build the table
				for (let i=0; i < max_row; i++) {
					table[i] = [];
					for (let j=0; j < max_col; j++) {
						table[i][j] = false;
					}
				}
				// Split into tokens and parse them one by one
				let tokens = expr.split(TOKEN_SEPARATOR);
				for (token of tokens) {
					// Check if this token should be negated (remove cells instead of adding)
					if (token[0] === NEGATE_OPERATOR) {
						negate = true;
						token = token.slice(1);
					} else {
						negate = false;
					}
					let {rows, columns} = parseToken(token, max_row, max_col);
					// Apply to the table
					for (row of rows) {
						for (column of columns) {
							table[row-1][column-1] = !negate;
						}
					}
				}
				// _printSamplesTable(table);


				// Everything is parsed, the table is final
				// Get all cells set to true in the table, and use them for the roll
				let sampleSet = [];
				for (let r=0; r < table.length; r++) {
					for (let c=0; c < table[r].length; c++) {
						if (table[r][c]) {
							sampleSet.push(`${ max_row===1 ? "" : num2let(r+1) }${ max_col===1 ? "" : c+1 }`);
						}
					}
				}

				return sampleSet;
			} catch (ex) {
				console.error(`Failed to parse the custom expression "${expr}"`);
				throw ex;
			}
		}

		////////////////////////////////////////////////////////////////////////
		// SAMPLE SET FUNCTIONS ////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

		function generateHairStyleSamples() {
			return ["S", "LW", "HW", "LC", "HC", "AC"];
		}

		function generateFertilitySamples() {
			return ["Y", "X", "X", "X", "X"];
		}

		////////////////////////////////////////////////////////////////////////
		// GLOBAL //////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

		/**
		 * Rolls all traits N times (according to global numberpicker)
		 * and fills the global output with clean formatted lines:
		 * <trait shortname> - <value> / ...
		 */ 
		function rollAll() {
			output = "";
			values = [traits.length];

			traits.forEach((trait, i) => {
				trait.roll(parseInt(document.getElementById("global-roll-count").value));
				values[i] = trait.rollOutputNode.value.split("\n");
			});

			for (let j=0; j < values[0].length; j++) {
				for (let i=0; i < traits.length; i++) {
					if (i != 0) {
						output += " / ";
					}
					const tn = traits[i].shortName
					output = output + (tn.length > 1 ? `${tn} - ` : '') + values[i][j];
				}
				output += "\n";
			}
			document.getElementById("global-roll-output").value = output;
			fitToContent(document.getElementById("global-roll-output"));
		}

		function copyAll() {
			navigator.clipboard.writeText(document.getElementById("global-roll-output").value);
		}

		////////////////////////////////////////////////////////////////////////
		// INIT ////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

		function init(argument) {

			// Initialize and generate traits
			traits = [
				new Trait("Skin tone", new Params(13, 11, [
						new Preset("Realistic", "A:F*"),
						new Preset("Fantasy", "G:M*")
					])),
				new Trait("Hair style", generateHairStyleSamples),
				new Trait("Hair color", new Params(1, 65, [
						new Preset("Realistic", "*1:26 /*14:16 *63:65 /*64"),
						new Preset("Fantasy", "*14:16 *27:60")
					])),
				new Trait("Eye color", new Params(8, 11, [
						new Preset("Realistic", "*1:7"),
						new Preset("Fantasy", "*8:11")
					])),
				new Trait("Fertility", generateFertilitySamples)
			];

			// Clear global output and set global buttons functionality
			document.getElementById("global-roll-output").value = "";
			document.getElementById("global-roll").addEventListener("click", rollAll);
			document.getElementById("global-copy").addEventListener("click", copyAll);
		}
	</script>
</head>
<body onload="init();">
	<section id="main">
		<div id="traits-container">

			<div id="_trait-template" hidden>
				<div class="top-part">
					<h3 class="trait-name">Trait name</h3>
					<div class="trait-params" hidden>
						<!-- OPTIONAL FORM FOR TRAIT PARAMETERS ----------------------->
						<form>
							<div class="radio-group">
								<label for="_trait-all">
									<input type="radio" name="_trait-presets" id="_trait-all" value="all" checked>
									<span>All</span>
								</label>
								<label for="_trait-custom">
									<input type="radio" name="_trait-presets" id="_trait-custom" value="custom">
									<span>Custom...</span>
								</label>
							</div>
							<input type="text" name="Range" class="row-range" size="18" placeholder="A2,3,5" disabled><br/>
						</form>
						<div class="error-message" hidden>Invalid expression!</div>
						<!-- END OPTIONAL FORM ---------------------------------------->
					</div>
				</div>
				<div class="bottom-part">
					<div class="roll-container">
						<button class="roll-button">Roll</button>
						<input type="number" class="roll-count" name="roll-count" value="1" min="1" max="999" placeholder="1">
						<label>time(s)</label><br>
					</div>
					<div class="divider"></div>
					<div class="roll-output-container">
						<textarea class="roll-output"></textarea>
						<button class="copy"><svg xmlns="http://www.w3.org/2000/svg" height="18px" viewBox="0 0 24 24" width="18px" fill="#000000"><path d="M0 0h24v24H0z" fill="none"/><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg></button>
					</div>
				</div>
			</div>
		</div>
		<div id="global">
			<!-- Global section: roll all, output + copy button -->
			<button class="roll-button" id="global-roll">Roll all</button>
			<input type="number" class="roll-count" id="global-roll-count" name="roll-count" value="1" min="1" max="999" placeholder="1">
			<label>time(s)</label>
			<div class="roll-output-container">
				<textarea class="roll-output" id="global-roll-output" cols="50"></textarea>
				<button class="copy" id="global-copy"><svg xmlns="http://www.w3.org/2000/svg" height="18px" viewBox="0 0 24 24" width="18px" fill="#000000"><path d="M0 0h24v24H0z" fill="none"/><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg></button>
			</div>
		</div>
		<details>
			<summary>Help: Custom selector syntax</summary>
			The "Custom" field of trait cards accepts a text selector that defines which values should be used for the roll.<br>
			These values are coordinates, made of a row (letter) and a column (number) (e.g B4), and you can include the ones you want by simply listing them: <tt>A2 A3 A4 A6 B7</tt><br>
			You can use shortcuts to specify multiple columns or rows at a time:<br>
			Enumerations:<br>
			<tt>A1 A3 A4 A12</tt> &rarr; <tt>A1,3,4,12</tt><br>
			<tt>A3 B3 F3 G3</tt> &rarr; <tt>A,B,F,G3</tt><br>
			Ranges:<br>
			<tt>A1 A2 A3 A4 A5</tt> &rarr; <tt>A1-5</tt><br>
			<tt>B4 C4 D4 E4</tt> &rarr; <tt>B-E4</tt><br>
			Wildcard:<br>
			<tt>A1 A2 A3 A4 A5</tt> &rarr; <tt>A*</tt> (if this trait has 5 columns)<br>

			When dealing with large ranges, exclusions can come quite handy:<br>
			<tt>A1 A3 A4 A5 A6 A8</tt> &rarr; <tt>A1-8 /A2 /A7</tt><br>
			(and some of the excluded values can be included back afterwards: <tt>A1-8 /A2-4 A3</tt>)<br><br>
			And of course, all of these can be combined together for mega-specific selectors: <tt>A-E* /D3,4,8 G5-8</tt>!
			<br>

		</details>
	</section>
	<footer id="about">
		<span>Appearance Roll Generator for CaV, created by TickingFeather, original idea by Arya22.</span><br/>
		<span>Licensed under the <a href="http://www.wtfpl.net/about/">WTF Public License</a>  —  Favicon credits: <a href="https://github.com/twitter/twemoji#attribution-requirements">Twemoji</a>, licensed under <a href="">CC-BY 4.0</a>.</span>
	</footer>
</body>
</html>